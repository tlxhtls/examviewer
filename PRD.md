# 환자 검사 통합 뷰어 애플리케이션 개발 계획서

**문서 버전**: 1.3 (Enhanced Version)  
**작성일**: 2025년 7월 16일  
**최종 수정일**: 2025년 1월 15일

## 1. 프로젝트 개요

### 1.1. 프로젝트 목표
복수의 NAS(Network Attached Storage)에 분산 저장된 환자 검사 결과(PDF, DOCX, 이미지 파일 등)를 단일 인터페이스에서 신속하게 검색하고, 여러 검사 결과를 한 화면에서 동시에 미리 볼 수 있는 데스크톱 애플리케이션을 개발한다. 이를 통해 의료진의 정보 접근성과 업무 효율성을 극대화하는 것을 목표로 한다.

### 1.2. 해결 과제
- **분산된 데이터**: 여러 NAS 및 하위 폴더에 흩어져 있는 파일을 통합 조회할 필요성
- **다양한 파일 형식**: '환자명', '등록번호' 등 일관성 없는 파일명 규칙 및 PDF, DOCX, 이미지 폴더 등 다양한 형태의 검사 결과를 모두 처리해야 함
- **성능 최적화**: 다수의 문서를 동시에 화면에 표시할 때 발생할 수 있는 심각한 성능 저하 문제 해결
- **실시간 동기화**: 파일의 생성, 이동, 삭제 등 변경 사항을 앱에 실시간으로 자동 반영

### 1.3. 최종 결과물
- Windows 환경에서 실행되는 Electron 기반 데스크톱 애플리케이션 (.exe)
- 사용자는 앱 내에서 환자명 또는 등록번호로 모든 관련 검사를 즉시 검색하고, 파일 생성일자와 함께 조회할 수 있다

## 2. 시스템 아키텍처

본 프로젝트는 프론트엔드-백엔드 분리형 아키텍처를 채택하며, 모든 컴포넌트는 유기적으로 상호작용한다.

- **사용자 (Client)**: Electron으로 패키징된 Next.js 애플리케이션을 사용
- **프론트엔드 (Next.js)**: UI/UX를 담당하며, 백엔드 API와 통신하여 데이터를 시각화
- **백엔드 (Python FastAPI)**: 핵심 비즈니스 로직, 파일 시스템 감시, DB 관리, API 제공을 담당
- **파일 시스템 감시 (Watchdog)**: NAS의 파일 변경을 실시간으로 감지하여 DB를 업데이트하는 독립 프로세스
- **데이터베이스 (SQLite)**: 파일의 메타데이터(경로, 환자 정보, 생성일 등)를 저장하는 경량 DB
- **데이터 저장소 (NAS)**: 원본 PDF, DOCX, 이미지 파일이 저장되는 위치

## 3. 개발 환경 및 프로젝트 구조

모노레포(Monorepo) 방식을 채택하여 프론트엔드와 백엔드 코드를 단일 Git 저장소에서 관리한다.

### 3.1. 기술 스택
- **프론트엔드**: Electron, Next.js (React), TypeScript, Tailwind CSS
- **백엔드**: Python 3.9+, FastAPI
- **데이터베이스**: SQLite
- **의존성 관리**: UV (Python), npm/yarn (Node.js)
- **핵심 라이브러리**:
  - **Backend**: watchdog (파일 시스템 감시), docx2pdf (DOCX→PDF 변환), PyMuPDF (fitz) (PDF 썸네일 생성), Pillow & reportlab (이미지→PDF 변환), SQLAlchemy (DB ORM)
  - **Frontend**: react-pdf (PDF 렌더링), axios (API 통신)
- **배포 관리**: NSSM (Windows 서비스 등록용), electron-builder

### 3.2. 폴더 구조
```
/patient-viewer-app/
├── 📁 backend/                # FastAPI 백엔드 프로젝트
│   ├── main.py               # FastAPI 앱 실행 파일
│   ├── watcher.py              # 파일 시스템 감시 독립 스크립트
│   ├── crud.py                 # DB CRUD 로직
│   ├── models.py               # DB 모델(스키마) 정의
│   ├── config.py               # 설정 관리
│   ├── utils/                  # 유틸리티 함수들
│   │   ├── file_parser.py      # 파일명 파싱 로직
│   │   ├── converter.py        # 파일 변환 로직
│   │   └── cache.py           # 캐싱 관리
│   ├── tests/                  # 단위 테스트
│   ├── logs/                   # 로그 파일
│   ├── pyproject.toml          # UV 의존성 관리
│   └── requirements.lock       # 고정된 의존성 버전
├── 📁 frontend/               # Next.js + Electron 프론트엔드 프로젝트
│   ├── main.js                 # Electron 메인 프로세스
│   ├── preload.js              # Electron 프리로드 스크립트
│   ├── pages/                  # Next.js 페이지
│   ├── components/             # React 컴포넌트
│   ├── hooks/                  # 커스텀 React 훅
│   ├── utils/                  # 유틸리티 함수
│   ├── styles/                 # Tailwind CSS 설정
│   ├── public/                 # 정적 에셋
│   ├── package.json
│   └── electron-builder.json   # 빌드 설정
├── 📁 docs/                   # 프로젝트 관련 문서
│   ├── architecture.md
│   ├── api_specification.md
│   ├── deployment_guide.md
│   └── user_manual.md
├── 📁 backup/                 # 주요 코드 및 DB 파일 백업
│   ├── backend_backup_YYYYMMDD.zip
│   └── db_backup_YYYYMMDD.sqlite
├── 📁 config/                 # 설정 파일들
│   ├── nas_paths.json          # NAS 경로 설정
│   ├── app_settings.json       # 애플리케이션 설정
│   └── logging.conf           # 로깅 설정
├── .gitignore
├── package.json              # 전체 프로젝트 관리 (스크립트 등)
└── README.md                 # 프로젝트 개요 및 설치 가이드
```

## 4. 핵심 기능 요구사항 (상세)

### 4.1. 백엔드 (FastAPI)

#### 4.1.1. 실시간 파일 인덱싱
- **구현**: watchdog 라이브러리를 사용한 독립 스크립트(watcher.py)로 구현
- **감시 대상**: `config/nas_paths.json`에 명시된 모든 NAS 경로 및 그 하위 폴더
- **파일명 파싱 규칙** (구체화):
  ```python
  # 지원하는 파일명 패턴들
  patterns = [
      r"(?P<name>[가-힣]+)_(?P<id>\d+)_.*",           # 홍길동_1234567_검사결과.pdf
      r"(?P<id>\d+)_(?P<name>[가-힣]+)_.*",           # 1234567_홍길동_MRI.docx
      r"(?P<name>[가-힣]+)\s+(?P<id>\d+).*",          # 홍길동 1234567 초음파.pdf
      r"(?P<id>\d+)\s+(?P<name>[가-힣]+).*",          # 1234567 홍길동 CT.pdf
      r".*(?P<name>[가-힣]{2,4}).*(?P<id>\d{6,8}).*", # 일반적인 한글이름+숫자ID
  ]
  ```
- **처리 이벤트**:
  - **on_created**: 새 파일 감지 시, 파일명/폴더명을 분석하여 환자명/등록번호 추출 및 파일 시스템에서 생성일자 메타데이터(os.path.getctime)를 조회하여 DB에 INSERT
  - **on_deleted**: 파일 삭제 감지 시, 해당 파일 경로를 기준으로 DB에서 DELETE
  - **on_moved**: 파일/폴더 이동 감지 시, 이동 전/후 경로를 이용해 DB에서 UPDATE
- **초기화**: watcher 스크립트 최초 실행 시, 지정된 모든 폴더를 전체 스캔하여 초기 데이터베이스를 구축하는 기능 필수
- **오류 처리**: 
  - 파일명 파싱 실패 시 로그 기록 후 건너뛰기
  - 네트워크 연결 실패 시 재시도 메커니즘
  - 파일 권한 오류 시 별도 로그 카테고리로 기록

#### 4.1.2. 데이터베이스 스키마 (SQLite)

**테이블명**: `medical_records`

| 컬럼명 | 데이터 타입 | 설명 | 예시 |
|:---|:---|:---|:---|
| id | INTEGER | Primary Key, Auto-increment | 1 |
| patient_name | TEXT | 환자명 (추출된 정보) | 홍길동 |
| patient_id | TEXT | 등록번호 (추출된 정보) | 1234567 |
| file_path | TEXT | 파일의 전체 UNC 경로 | //NAS1/scans/report.docx |
| file_type | TEXT | 파일 종류 ('PDF', 'DOCX', 'IMAGE_FOLDER') | DOCX |
| file_size | INTEGER | 파일 크기 (바이트) | 2048000 |
| file_creation_date | DATETIME | 파일 시스템상의 생성일 | 2025-07-16 10:00:00 |
| file_modified_date | DATETIME | 파일 시스템상의 수정일 | 2025-07-16 11:00:00 |
| thumbnail_path | TEXT | 썸네일 캐시 경로 | cache/thumbnails/1.png |
| parsing_confidence | FLOAT | 파일명 파싱 신뢰도 (0-1) | 0.95 |
| created_at | DATETIME | 레코드 생성 시각 | 2025-07-16 22:10:00 |
| modified_at | DATETIME | 레코드 수정 시각 | 2025-07-16 22:10:00 |

**인덱스 설정**:
```sql
CREATE INDEX idx_patient_name ON medical_records(patient_name);
CREATE INDEX idx_patient_id ON medical_records(patient_id);
CREATE INDEX idx_file_creation_date ON medical_records(file_creation_date);
CREATE INDEX idx_composite_search ON medical_records(patient_name, patient_id, file_creation_date);
```

#### 4.1.3. API 엔드포인트 설계

**GET /api/search**
- **설명**: 환자명 또는 등록번호로 검사 기록 검색
- **쿼리 파라미터**: 
  - `q: str` (검색어, 필수)
  - `limit: int = 50` (결과 개수 제한)
  - `offset: int = 0` (페이지네이션)
  - `sort_by: str = "file_creation_date"` (정렬 기준)
  - `sort_order: str = "desc"` (정렬 순서)
- **응답**: 200 OK
```json
{
  "total": 5,
  "results": [
    {
      "id": 1, 
      "patient_name": "홍길동", 
      "patient_id": "1234567", 
      "file_type": "PDF", 
      "file_creation_date": "2024-10-01T10:00:00",
      "file_size": 2048000,
      "parsing_confidence": 0.95
    }
  ]
}
```

**GET /api/file/{record_id}**
- **설명**: 원본 파일(PDF, DOCX 등)을 스트리밍으로 제공
- **로직**: DOCX 파일 요청 시, 백엔드에서 PDF로 변환 후 제공
- **캐싱**: 변환된 PDF는 임시 캐시에 저장 (TTL: 1시간)
- **응답**: 200 OK with FileResponse (PDF 파일 데이터)
- **헤더**: 
  - `Content-Type: application/pdf`
  - `Content-Disposition: inline; filename="document.pdf"`

**GET /api/thumbnail/{record_id}**
- **설명**: 지정된 기록의 첫 페이지를 이미지(PNG) 썸네일로 제공
- **로직**: DOCX 파일의 경우, PDF로 변환 후 썸네일을 생성
- **캐싱**: 생성된 썸네일은 영구 캐시에 저장
- **응답**: 200 OK with FileResponse (이미지 파일 데이터)
- **썸네일 규격**: 300x400 픽셀, PNG 형식

**GET /api/health**
- **설명**: 시스템 상태 확인
- **응답**: 
```json
{
  "status": "healthy",
  "database": "connected",
  "watcher": "running",
  "cache_size": "150MB",
  "indexed_files": 15420
}
```

#### 4.1.4. 파일 타입별 처리
- **PDF 처리**: PyMuPDF를 사용하여 직접 썸네일 생성 및 파일 제공
- **DOCX 처리 (핵심)**: file_type이 'DOCX'인 파일을 요청받으면, docx2pdf 라이브러리를 사용하여 백그라운드에서 DOCX를 임시 PDF 파일로 변환한다. 그 후, 변환된 PDF를 기반으로 썸네일을 생성하거나 파일 자체를 스트리밍한다. 이로써 모든 문서 처리 파이프라인을 PDF 기반으로 통일한다.
- **이미지 폴더 처리**: 해당 폴더 내의 모든 이미지 파일을 Pillow로 읽어들여 reportlab을 통해 단일 PDF 파일로 동적 생성 후 스트리밍으로 반환한다.

#### 4.1.5. 캐싱 전략 (신규 추가)
- **썸네일 캐시**: 
  - 위치: `backend/cache/thumbnails/`
  - 명명 규칙: `{record_id}_{file_hash[:8]}.png`
  - 만료: 원본 파일 수정시까지 영구 보관
- **PDF 변환 캐시**:
  - 위치: `backend/cache/converted/`
  - TTL: 1시간
  - 크기 제한: 최대 1GB, LRU 방식으로 정리
- **메모리 캐시**:
  - 검색 결과: 5분간 캐시
  - 파일 메타데이터: 10분간 캐시

#### 4.1.6. 로깅 및 모니터링 (신규 추가)
- **로그 레벨**: DEBUG, INFO, WARNING, ERROR, CRITICAL
- **로그 파일**:
  - `app.log`: 일반 애플리케이션 로그
  - `watcher.log`: 파일 감시 관련 로그
  - `error.log`: 오류 전용 로그
- **로그 로테이션**: 일일 단위, 최대 30일 보관
- **성능 메트릭**:
  - API 응답 시간
  - 파일 변환 시간
  - 데이터베이스 쿼리 시간
  - 캐시 히트율

### 4.2. 프론트엔드 (Electron + Next.js)

#### 4.2.1. UI/UX 설계
- **메인 윈도우**: 단일 창 애플리케이션 (1200x800 기본 크기)
- **상단**: 고정된 검색 바(Bar) 영역
  - 검색 입력 필드
  - 정렬 옵션 드롭다운
  - 필터 버튼 (날짜 범위, 파일 형식)
- **컨텐츠 영역**: 검색 결과가 표시되는 그리드(Grid) 뷰
  - 반응형 그리드: 창 크기에 따라 2-6열 자동 조정
  - 각 그리드 아이템: 썸네일 이미지 + 파일 생성일자 + 환자 정보
- **상태 바**: 하단에 현재 로딩 상태, 총 결과 수 표시

#### 4.2.2. '하이브리드 렌더링' 전략 (핵심 성능 최적화)
- **초기 로드 (Thumbnail-First)**: 
  - 사용자가 환자를 검색하면, 프론트엔드는 백엔드의 `/api/search`를 호출하여 결과 목록(JSON)을 받는다
  - 프론트엔드는 이 목록을 순회하며 각 레코드의 id를 이용해 `/api/thumbnail/{id}`를 호출, 가벼운 이미지 썸네일들만 가져와 그리드에 즉시 표시한다
  - 이 단계에서는 실제 문서 파일을 전혀 로드하지 않으므로 초기 응답성이 매우 뛰어나다
- **사용자 상호작용 (Lazy Loading)**: 
  - 사용자가 특정 썸네일 위에 마우스를 올리거나(Hover) 클릭(Click)하는 이벤트를 감지한다
- **동적 컴포넌트 교체**: 
  - 이벤트가 발생하면, 해당 썸네일 이미지 컴포넌트를 실제 인터랙티브 PDF 뷰어(react-pdf 컴포넌트)로 동적으로 교체(replace)한다
  - 이때 뷰어 컴포넌트의 file prop에는 백엔드 파일 스트리밍 주소(`http://<backend>/api/file/{id}`)를 전달한다
- **성능 확보**: 
  - 이 전략을 통해 사용자는 모든 문서를 한눈에 보는 듯한 경험을 하면서도, 시스템은 실제로 사용자가 상호작용하는 1~2개의 문서만 실시간으로 처리하게 된다
  - 이는 다수의 무거운 PDF를 동시에 렌더링할 때 발생하는 브라우저 메모리 과부하 및 UI 프리징 현상을 원천적으로 방지한다

#### 4.2.3. 사용자 설정 관리 (신규 추가)
- **설정 파일**: `config/user_settings.json`
- **설정 항목**:
  - 백엔드 서버 주소
  - 그리드 레이아웃 (열 개수, 썸네일 크기)
  - 기본 정렬 옵션
  - 캐시 크기 제한
  - 자동 업데이트 설정
- **설정 UI**: 메뉴바 > 설정에서 접근 가능

#### 4.2.4. 오프라인 모드 지원 (신규 추가)
- **로컬 캐시**: 최근 검색 결과 및 썸네일을 로컬에 저장
- **동기화**: 온라인 복구 시 자동으로 최신 데이터와 동기화
- **오프라인 표시**: 네트워크 상태에 따른 UI 피드백

## 5. 비기능적 요구사항

### 5.1. 성능 (Performance)
- **검색 응답**: 검색어 입력 후 결과 목록이 표시되기까지 1초 이내
- **썸네일 로딩**: 검색 결과 20개 기준, 모든 썸네일이 화면에 표시되기까지 3초 이내
- **PDF 렌더링**: 사용자가 썸네일과 상호작용 후, 실제 PDF의 첫 페이지가 렌더링 되기까지 1.5초 이내
- **메모리 사용량**: 프론트엔드 앱이 500MB 이하 메모리 사용
- **동시 사용자**: 최대 10명의 동시 사용자 지원

### 5.2. 안정성 (Stability)
- **서비스 데몬화**: 
  - watcher.py 스크립트는 NSSM 유틸리티를 사용하여 Windows 서비스로 등록한다
  - 시스템 재시작 시 자동으로 실행되며, 예기치 않은 오류로 프로세스가 종료될 경우 자동으로 재시작되도록 설정하여 24/7 무중단 운영을 보장한다
- **예외 처리**: 
  - 파일 I/O(읽기, 쓰기, 변환) 및 모든 네트워크 API 호출 과정에서 발생할 수 있는 예외(파일 없음, 권한 없음, 네트워크 오류 등)를 try-except 블록으로 철저히 처리하여, 일부 파일의 오류가 전체 애플리케이션의 중단으로 이어지지 않도록 한다
- **데이터 무결성**: 
  - 데이터베이스 트랜잭션 롤백 메커니즘
  - 정기적인 데이터베이스 백업 (일일)
  - 파일 체크섬을 통한 데이터 검증

### 5.3. 보안 (Security)
- **경로 추상화**: 
  - 클라이언트(프론트엔드)는 NAS의 실제 파일 경로(//NAS1/...)에 절대 직접 접근하지 않는다
  - 모든 파일 관련 요청은 백엔드 API를 통해 이루어지며, 백엔드가 중개자(proxy) 역할을 하여 실제 경로를 노출하지 않는다
- **API 엔드포인트 보호**: 
  - (향후 확장 고려) 내부망 사용을 전제로 하지만, API 키 또는 기타 인증 메커니즘을 추가하여 허가된 클라이언트만 백엔드에 접근할 수 있도록 설계할 수 있다
- **데이터 암호화**: 
  - 전송 중 데이터: HTTPS 적용
  - 저장된 캐시: 민감 정보 포함 시 암호화

### 5.4. 사용성 (Usability)
- **직관적 UI**: 
  - IT에 익숙하지 않은 의료진도 별도의 교육 없이 즉시 사용할 수 있도록 UI를 최대한 단순하고 직관적으로 설계한다
- **명확한 상태 표시**: 
  - 검색 중, 로딩 중, 오류 발생 등 애플리케이션의 현재 상태를 사용자에게 명확하게 시각적으로 피드백한다 (로딩 스피너, 오류 메시지 등)
- **키보드 단축키**: 
  - 검색: Ctrl+F
  - 새로고침: F5
  - 설정: Ctrl+,
- **접근성**: 
  - 고대비 모드 지원
  - 폰트 크기 조절 기능

## 6. 개발 단계 및 이정표 (Milestones)

### Phase 1: 백엔드 핵심 기능 개발 (~2주)
- [ ] **개발 환경 설정**
  - [ ] UV를 사용한 Python 환경 설정 및 의존성 관리
  - [ ] FastAPI 프로젝트 초기 설정
  - [ ] SQLite 데이터베이스 스키마 설계 및 구현
- [ ] **파일 시스템 모니터링**
  - [ ] watchdog을 이용한 실시간 파일 감시 로직 구현
  - [ ] 파일명 파싱 규칙 구현 및 테스트
  - [ ] 데이터베이스 CRUD 로직 완성 (파일 생성일자 수집 포함)
- [ ] **API 개발**
  - [ ] 3가지 핵심 API (/search, /file, /thumbnail) 기능 구현 완료
  - [ ] DOCX 파일 변환 및 썸네일 생성 로직 구현
  - [ ] 캐싱 시스템 구현
- [ ] **테스트**
  - [ ] 단위 테스트: 각 API 및 인덱싱 로직 기능 검증
  - [ ] 통합 테스트: 파일 시스템과 데이터베이스 연동 테스트

### Phase 2: 프론트엔드 기본 구조 개발 (~2주)
- [ ] **개발 환경 설정**
  - [ ] Electron + Next.js 프로젝트 환경 설정
  - [ ] TypeScript 및 Tailwind CSS 설정
- [ ] **기본 UI 구현**
  - [ ] 기본 레이아웃(검색 바, 그리드 영역) 구현
  - [ ] 반응형 그리드 시스템 구현
  - [ ] 로딩 상태 및 오류 처리 UI
- [ ] **API 연동**
  - [ ] 백엔드 /search API 연동
  - [ ] 생성일자가 포함된 썸네일 그리드 표시 기능 구현
  - [ ] 검색 및 필터링 기능 구현

### Phase 3: 고급 기능 통합 및 고도화 (~1주)
- [ ] **하이브리드 렌더링 구현**
  - [ ] 썸네일-PDF 뷰어 동적 전환 로직 구현
  - [ ] react-pdf를 이용한 PDF 뷰어 통합
  - [ ] 스크롤, 확대/축소 등 PDF 뷰어 기능 추가
- [ ] **파일 형식 지원 확장**
  - [ ] 이미지 폴더 처리 기능 구현
  - [ ] DOCX 파일을 PDF로 변환하여 보여주는 기능 최종 연동
- [ ] **성능 최적화**
  - [ ] 가상화 스크롤 구현 (대량 결과 처리)
  - [ ] 메모리 사용량 최적화

### Phase 4: 배포 및 안정화 (~1주)
- [ ] **배포 준비**
  - [ ] electron-builder를 사용하여 배포용 .exe 설치 파일 패키징
  - [ ] 자동 업데이트 메커니즘 구현
- [ ] **서비스 등록**
  - [ ] watcher.py 스크립트를 NSSM을 통해 Windows 서비스로 등록하는 상세 절차 구현
  - [ ] 배포 자동화 스크립트 작성
- [ ] **테스트 및 최적화**
  - [ ] 실제 운영 환경과 동일한 조건의 테스트 NAS 환경에서 통합 테스트 수행
  - [ ] 발견된 버그 수정 및 성능 튜닝
- [ ] **문서화**
  - [ ] 배포 가이드 문서 작성
  - [ ] 최종 사용자를 위한 기능 설명 및 문제 해결 가이드가 포함된 사용자 매뉴얼 작성

## 7. 품질 보증 및 테스트 전략

### 7.1. 테스트 종류
- **단위 테스트**: 
  - Backend: pytest를 사용한 각 함수/클래스 테스트
  - Frontend: Jest를 사용한 컴포넌트 테스트
- **통합 테스트**: 
  - API 엔드포인트 전체 플로우 테스트
  - 파일 시스템과 데이터베이스 연동 테스트
- **E2E 테스트**: 
  - Playwright를 사용한 사용자 시나리오 테스트
- **성능 테스트**: 
  - 대량 파일 처리 성능 테스트
  - 동시 사용자 부하 테스트

### 7.2. 테스트 데이터
- **Mock NAS 환경**: 다양한 파일명 패턴을 가진 테스트 파일 세트
- **성능 테스트용**: 10,000개 이상의 파일을 포함한 대용량 테스트 세트

## 8. 배포 및 운영

### 8.1. 배포 전략
- **스테이징 환경**: 운영 환경과 동일한 구성의 테스트 환경
- **점진적 배포**: 소수 사용자 대상 베타 테스트 후 전체 배포
- **롤백 계획**: 문제 발생 시 이전 버전으로 즉시 롤백 가능한 메커니즘

### 8.2. 모니터링
- **시스템 모니터링**: 
  - CPU, 메모리, 디스크 사용량
  - 네트워크 연결 상태
- **애플리케이션 모니터링**: 
  - API 응답 시간
  - 오류 발생률
  - 사용자 활동 로그

### 8.3. 유지보수
- **정기 백업**: 
  - 데이터베이스: 일일 자동 백업
  - 설정 파일: 주간 백업
- **업데이트 관리**: 
  - 자동 업데이트 메커니즘
  - 사용자 알림 시스템

## 9. 문서 및 백업 정책

### 9.1. 문서화 (/docs 폴더)
- 프로젝트의 모든 주요 산출물(본 개발 계획서, API 명세서, 시스템 아키텍처 다이어그램 등)은 `/docs` 폴더 내에 마크다운 형식으로 저장하고 관리한다
- 모든 개발자는 기능 추가 또는 주요 변경 사항 발생 시, 관련 문서를 즉시 업데이트하여 항상 최신 상태를 유지할 의무가 있다. 이는 개발자 본인과 AI 협업 파트너 간의 원활한 소통과 프로젝트 연속성 유지를 위함이다

### 9.2. 백업 (/backup 폴더)
- 각 개발 단계(Phase) 완료 시점 및 중요한 기능 구현이 끝났을 때, backend와 frontend 소스 코드 전체 및 database.sqlite 파일을 압축하여 백업한다
- 백업 파일명은 `project_backup_YYYYMMDD_phasename.zip` 형식으로 명명하여, 특정 시점의 스냅샷을 명확히 식별하고 필요시 쉽게 복원할 수 있도록 한다. 이는 코드 유실 방지 및 버전 관리를 위한 중요한 안전장치이다

## 10. 위험 관리 및 대응 계획

### 10.1. 주요 위험 요소
- **네트워크 연결 불안정**: NAS 접근 실패 시 자동 재시도 및 오프라인 모드 지원
- **대용량 파일 처리**: 메모리 부족 방지를 위한 스트리밍 처리 및 청크 단위 작업
- **동시성 문제**: 데이터베이스 락 메커니즘 및 큐 시스템 도입
- **파일 형식 변화**: 새로운 파일 형식 지원을 위한 플러그인 아키텍처 고려

### 10.2. 성능 저하 대응
- **인덱스 최적화**: 정기적인 데이터베이스 인덱스 재구성
- **캐시 정리**: 디스크 공간 부족 시 자동 캐시 정리
- **메모리 누수 방지**: 정기적인 가비지 컬렉션 및 메모리 모니터링

---

**문서 끝**

*이 문서는 프로젝트 진행에 따라 지속적으로 업데이트되며, 모든 변경 사항은 git commit을 통해 추적됩니다.*